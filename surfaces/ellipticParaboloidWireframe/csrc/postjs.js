/******************************************************************************
 *                                  LICENSE                                   *
 ******************************************************************************
 *  This file is free software: you can redistribute it and/or modify         *
 *  it under the terms of the GNU General Public License as published by      *
 *  the Free Software Foundation, either version 3 of the License, or         *
 *  (at your option) any later version.                                       *
 *                                                                            *
 *  This file is distributed in the hope that it will be useful,              *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
 *  GNU General Public License for more details.                              *
 *                                                                            *
 *  You should have received a copy of the GNU General Public License         *
 *  along with this file.  If not, see <https://www.gnu.org/licenses/>.       *
 ******************************************************************************
 *  Purpose:                                                                  *
 *      Creates aliases for the functions generated by emscripten. The C      *
 *      for a function is function_name and emscripten prepends an underscore *
 *      producing _function_name. This file allows the function to be called  *
 *      in JavaScript by typing functionName, as is most common.              *
 ******************************************************************************
 *  Author:     Ryan Maguire                                                  *
 *  Date:       October 30, 2025                                              *
 ******************************************************************************/
createModule.generateIndices = createModule._generate_indices;
createModule.generateMesh = createModule._generate_mesh;
createModule.getIndexBuffer = createModule._get_index_buffer;
createModule.getMeshBuffer = createModule._get_mesh_buffer;
createModule.rotateMesh = createModule._rotate_mesh;
createModule.setRotationAngle = createModule._set_rotation_angle;

/******************************************************************************
 *  Function:                                                                 *
 *      animate                                                               *
 *  Purpose:                                                                  *
 *      Rotates the elliptic paraboloid slowly about the z axis.              *
 *  Arguments:                                                                *
 *      None.                                                                 *
 *  Output:                                                                   *
 *      None.                                                                 *
 ******************************************************************************/
function animate(renderer, scene, camera, surface, arraySize) {

    /*  Rotate the object slightly as time passes.                            */
    const mesh = surface.geometry.attributes.position;

    createModule.rotateMesh(mesh.array.byteOffset, arraySize);
    mesh.needsUpdate = true;

    /*  Re-render the newly rotated scene.                                    */
    renderer.render(scene, camera);
}

/******************************************************************************
 *  Function:                                                                 *
 *      setupScene                                                            *
 *  Purpose:                                                                  *
 *      Creates the scene, which is a wireframe elliptic paraboloid and a     *
 *      black background.                                                     *
 *  Arguments:                                                                *
 *      None.                                                                 *
 *  Output:                                                                   *
 *      None.                                                                 *
 ******************************************************************************/
function setupGeometry(three, width, height) {

    const numberOfPoints = width * height;
    const bufferSize = 3 * numberOfPoints;
    const indexSize = 2 * (2 * numberOfPoints - width - height);

    /*  three.js has parametric function tools, but this renders the object   *
     *  with diagonals across the constituent squares, creating a mesh of     *
     *  triangles. To see a square pattern, we'll need to make our own buffer.*/
    const geometry = new three.BufferGeometry();

    const meshBuffer = createModule.HEAPF32.buffer;
    const indexBuffer = createModule.HEAPU32.buffer;

    const meshPtr = createModule.getMeshBuffer();
    const indexPtr = createModule.getIndexBuffer();

    const mesh = new Float32Array(meshBuffer, meshPtr, bufferSize);
    const indices = new Uint32Array(indexBuffer, indexPtr, indexSize);

    /*  The vertices for the object will by typed as 32-bit floats. We'll     *
     *  need a variable for the buffer attributes as well.                    */
    let geometryAttributes, indexAttribute;

    createModule.generateMesh(mesh.byteOffset, width, height);
    createModule.generateIndices(indices.byteOffset, width, height);

    /*  We can now create the buffer attributes. The data is 3D, hence the    *
     *  itemSize parameter is 3.                                              */
    geometryAttributes = new three.BufferAttribute(mesh, 3);
    indexAttribute = new three.BufferAttribute(indices, 1);

    /*  Add the vertices and index array to the mesh.                         */
    geometry.setAttribute('position', geometryAttributes);
    geometry.setIndex(indexAttribute);

    return geometry;
}
/*  End of setupGeometry.                                                     */

createModule.animate = animate;
createModule.setupGeometry = setupGeometry;
